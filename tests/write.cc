#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <stdexcept>

#include <tinyply.h>

int write_file(const std::string& path, std::ios::openmode mode)
{
	using namespace tinyply;

	std::vector<float> vertices;
	std::vector<std::vector<int32_t>> vertex_indices;

	// Per-vertex elements, flattened
	vertices = {
		0.f, 0.f, 0.f,
		1.f, 0.f, 0.f,
		0.f, 1.f, 0.f,
		0.f, 0.f, 1.f,
		2.f, 2.f, 0.f,
		2.f, 3.f, 0.f,
		3.f, 2.f, 0.f,
		2.f, 2.f, 1.f,
	};

	// Per-face elements
	vertex_indices.push_back({ 0, 2, 1 });
	vertex_indices.push_back({ 0, 1, 3 });
	vertex_indices.push_back({ 0, 3, 2 });
	vertex_indices.push_back({ 1, 2, 3 });
	vertex_indices.push_back({ 1, 4, 5, 2 });
	vertex_indices.push_back({ 4, 5, 6 });
	vertex_indices.push_back({ 4, 7, 5 });
	vertex_indices.push_back({ 4, 6, 7 });
	vertex_indices.push_back({ 5, 7, 6 });

	// Tinyply does not perform any file i/o internally
	std::filebuf fb;
	fb.open(path, mode);
	std::ostream outputStream(&fb);

	try
	{
		PlyFile myFile;

		myFile.add_properties_to_element("vertex", { "x", "y", "z" }, vertices);
		myFile.add_properties_to_element("face", { "vertex_indices" }, vertex_indices, 0, PlyProperty::Type::UINT8);

		myFile.comments.push_back("generated by tinyply");
		bool is_binary = mode & std::ios::binary;
		myFile.write(outputStream, is_binary);

		fb.close();
	}
	catch (const std::exception& e)
	{
		std::cerr << "Caught exception: " << e.what() << std::endl;
		return 1;
	}
	return 0;
}

int main(int argc, char *argv[])
{
	int res = 0;
	res += write_file("test_ascii.ply", std::ios::out);
	res += write_file("test_binary.ply", std::ios::out | std::ios::binary);
	return res;
}
